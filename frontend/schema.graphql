"""Global query"""
type Query {
  allLabels(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    sourceId: ID
    sourceId_In: [ID]
    soundId: ID
    soundId_In: [ID]
    parentId: ID
    parentId_In: [ID]
    nickname: String
    nickname_Icontains: String
    shape: SignalShapeEnum
    plurality: SignalPluralityEnum
    minFrequency: Int
    minFrequency_Lt: Int
    minFrequency_Lte: Int
    minFrequency_Gt: Int
    minFrequency_Gte: Int
    maxFrequency: Int
    maxFrequency_Lt: Int
    maxFrequency_Lte: Int
    maxFrequency_Gt: Int
    maxFrequency_Gte: Int
    meanDuration: Float
    meanDuration_Lt: Float
    meanDuration_Lte: Float
    meanDuration_Gt: Float
    meanDuration_Gte: Float
  ): LabelNodeNodeConnection
  labelById(id: ID!): LabelNode
  allSounds(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    parentId: ID
    parentId_In: [ID]
    englishName: String
    englishName_Icontains: String
    frenchName: String
    frenchName_Icontains: String
    codeName: String
    codeName_Icontains: String
    taxon: String
    taxon_Icontains: String
  ): SoundNodeNodeConnection
  soundById(id: ID!): SoundNode
  allSources(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    parentId: ID
    parentId_In: [ID]
    englishName: String
    englishName_Icontains: String
    latinName: String
    latinName_Icontains: String
    frenchName: String
    frenchName_Icontains: String
    codeName: String
    codeName_Icontains: String
    taxon: String
    taxon_Icontains: String
  ): SourceNodeNodeConnection
  sourceById(id: ID!): SourceNode
  allAuthors(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    order: Int
    order_Lt: Int
    order_Lte: Int
    order_Gt: Int
    order_Gte: Int
    bibliographyId: ID
    bibliographyId_In: [ID]
    personId: ID
    personId_In: [ID]
  ): AuthorNodeNodeConnection
  authorById(id: ID!): AuthorNode
  allArticle(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    type: String
    type_In: [String]
    title: String
    title_Icontains: String
    journal: String
    journal_Icontains: String
    doi: String
    status: String
    publicationDate: Date
    publicationDate_Lt: Date
    publicationDate_Lte: Date
    publicationDate_Gt: Date
    publicationDate_Gte: Date
  ): ArticleNodeNodeConnection
  articleById(id: ID!): ArticleNode
  allSoftware(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    type: String
    type_In: [String]
    title: String
    title_Icontains: String
    publicationPlace: String
    publicationPlace_Icontains: String
    doi: String
    status: String
    publicationDate: Date
    publicationDate_Lt: Date
    publicationDate_Lte: Date
    publicationDate_Gt: Date
    publicationDate_Gte: Date
  ): SoftwareNodeNodeConnection
  softwareById(id: ID!): SoftwareNode
  allConference(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    type: String
    type_In: [String]
    title: String
    title_Icontains: String
    conferenceName: String
    conferenceName_Icontains: String
    conferenceLocation: String
    conferenceLocation_Icontains: String
    doi: String
    status: String
    publicationDate: Date
    publicationDate_Lt: Date
    publicationDate_Lte: Date
    publicationDate_Gt: Date
    publicationDate_Gte: Date
  ): ConferenceNodeNodeConnection
  conferenceById(id: ID!): ConferenceNode
  allPoster(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    type: String
    type_In: [String]
    title: String
    title_Icontains: String
    conferenceName: String
    conferenceName_Icontains: String
    conferenceLocation: String
    conferenceLocation_Icontains: String
    doi: String
    status: String
    publicationDate: Date
    publicationDate_Lt: Date
    publicationDate_Lte: Date
    publicationDate_Gt: Date
    publicationDate_Gte: Date
  ): PosterNodeNodeConnection
  posterById(id: ID!): PosterNode
  allBibliography(before: String, after: String, first: Int, last: Int): BibliographyUnionConnection
  bibliographyById(id: ID!): BibliographyUnion
  allMaintenances(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    typeId: ID
    typeId_In: [ID]
    maintainerId: ID
    maintainerId_In: [ID]
    maintainerInstitutionId: ID
    maintainerInstitutionId_In: [ID]
    platformId: ID
    platformId_In: [ID]
    equipmentId: ID
    equipmentId_In: [ID]
    date: Date
    date_Lt: Date
    date_Lte: Date
    date_Gt: Date
    date_Gte: Date
  ): MaintenanceNodeNodeConnection
  maintenanceById(id: ID!): MaintenanceNode
  allMaintenanceTypes(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    interval: Float
    interval_Lt: Float
    interval_Lte: Float
    interval_Gt: Float
    interval_Gte: Float
  ): MaintenanceTypeNodeNodeConnection
  allPlatforms(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    ownerId: BigInt
    ownerId_In: [BigInt]
    providerId: ID
    providerId_In: [ID]
    name: String
    name_Icontains: String
  ): PlatformNodeNodeConnection
  platformById(id: ID!): PlatformNode
  allPlatformTypes(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    isMobile: Boolean
  ): PlatformTypeNodeNodeConnection
  allEquipments(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    serialNumber: String
    serialNumber_Icontains: String
    purchaseDate: Date
    purchaseDate_Lt: Date
    purchaseDate_Lte: Date
    purchaseDate_Gt: Date
    purchaseDate_Gte: Date
    name: String
    name_Icontains: String
    sensitivity: Float
    sensitivity_Lt: Float
    sensitivity_Lte: Float
    sensitivity_Gt: Float
    sensitivity_Gte: Float
    sensitivity_Isnull: Boolean
  ): EquipmentNodeNodeConnection
  equipmentById(id: ID!): EquipmentNode
  allEquipmentModels(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_In: [String]
    batterySlotsCount: Int
    batterySlotsCount_Lt: Int
    batterySlotsCount_Lte: Int
    batterySlotsCount_Gt: Int
    batterySlotsCount_Gte: Int
    batterySlotsCount_Isnull: Boolean
    batteryType: String
    batteryType_In: [String]
    cables: String
    cables_In: [String]
  ): EquipmentModelNodeNodeConnection
  allFileFormats(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
  ): FileFormatNodeNodeConnection
  fileFormatById(id: ID!): FileFormatNode
  allAudioFiles(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    filename: String
    filename_Icontains: String
    storageLocation: String
    storageLocation_Icontains: String
    fileSize: Int
    fileSize_Lt: Int
    fileSize_Lte: Int
    fileSize_Gt: Int
    fileSize_Gte: Int
    accessibility: String
  ): AudioFileNodeNodeConnection
  audioFileById(id: ID!): AudioFileNode
  allDetectionFiles(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: Decimal
    id_In: [String]
    filename: String
    filename_Icontains: String
    storageLocation: String
    storageLocation_Icontains: String
    fileSize: Int
    fileSize_Lt: Int
    fileSize_Lte: Int
    fileSize_Gt: Int
    fileSize_Gte: Int
    accessibility: String
  ): DetectionFileNodeNodeConnection
  detectionFileById(id: ID!): DetectionFileNode
  allFiles(before: String, after: String, first: Int, last: Int): FileUnionConnection
  fileById(id: ID!): FileUnion
  allProjects(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    accessibility: AccessibilityEnum
    doi: String
    startDate: Date
    startDate_Lte: Date
    startDate_Lt: Date
    startDate_Gte: Date
    startDate_Gt: Date
    endDate: Date
    endDate_Lte: Date
    endDate_Lt: Date
    endDate_Gte: Date
    endDate_Gt: Date
    projectGoal: String
    projectGoal_Icontains: String
    financing: FinancingEnum
  ): ProjectNodeOverrideNodeConnection
  projectById(id: ID!): ProjectNode
  allProjectTypes(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
  ): ProjectTypeNodeNodeConnection
  allSites(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    projectId: ID
    projectId_In: [ID]
  ): SiteNodeNodeConnection
  siteById(id: ID!): SiteNode
  allCampaigns(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    projectId: ID
    projectId_In: [ID]
  ): CampaignNodeNodeConnection
  campaignById(id: ID!): CampaignNode
  allDeployments(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    projectId: ID
    projectId_In: [ID]
    siteId: ID
    siteId_In: [ID]
    campaignId: ID
    campaignId_In: [ID]
    platformId: ID
    platformId_In: [ID]
    longitude: Float
    longitude_Lt: Float
    longitude_Lte: Float
    longitude_Gt: Float
    longitude_Gte: Float
    latitude: Float
    latitude_Lt: Float
    latitude_Lte: Float
    latitude_Gt: Float
    latitude_Gte: Float
    name: String
    name_Icontains: String
    bathymetricDepth: Int
    bathymetricDepth_Lt: Int
    bathymetricDepth_Lte: Int
    bathymetricDepth_Gt: Int
    bathymetricDepth_Gte: Int
    deploymentDate: DateTime
    deploymentDate_Lt: DateTime
    deploymentDate_Lte: DateTime
    deploymentDate_Gt: DateTime
    deploymentDate_Gte: DateTime
    deploymentVessel: String
    deploymentVessel_Icontains: String
    recoveryDate: DateTime
    recoveryDate_Lt: DateTime
    recoveryDate_Lte: DateTime
    recoveryDate_Gt: DateTime
    recoveryDate_Gte: DateTime
    recoveryVessel: String
    recoveryVessel_Icontains: String
    description_Icontains: String
    project_WebsiteProject_Id: Decimal
  ): DeploymentNodeNodeConnection
  deploymentById(id: ID!): DeploymentNode
  allChannelConfigurations(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    recorderSpecification_Isnull: Boolean
    detectorSpecification_Isnull: Boolean
    continuous: Boolean
    dutyCycleOn: Int
    dutyCycleOn_Lt: Int
    dutyCycleOn_Lte: Int
    dutyCycleOn_Gt: Int
    dutyCycleOn_Gte: Int
    dutyCycleOff: Int
    dutyCycleOff_Lt: Int
    dutyCycleOff_Lte: Int
    dutyCycleOff_Gt: Int
    dutyCycleOff_Gte: Int
    instrumentDepth: Int
    instrumentDepth_Lt: Int
    instrumentDepth_Lte: Int
    instrumentDepth_Gt: Int
    instrumentDepth_Gte: Int
    timezone: String
    harvestStartingDate: DateTime
    harvestStartingDate_Lt: DateTime
    harvestStartingDate_Lte: DateTime
    harvestStartingDate_Gt: DateTime
    harvestStartingDate_Gte: DateTime
    harvestEndingDate: DateTime
    harvestEndingDate_Lt: DateTime
    harvestEndingDate_Lte: DateTime
    harvestEndingDate_Gt: DateTime
    harvestEndingDate_Gte: DateTime
    datasetId: ID
  ): ChannelConfigurationNodeNodeConnection
  channelConfigurationById(id: ID!): ChannelConfigurationNode
  allPersons(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    firstName: String
    firstName_Icontains: String
    lastName: String
    lastName_Icontains: String
    mail: String
    mail_Icontains: String
    website: String
    website_Icontains: String
  ): PersonNodeNodeConnection
  personById(id: ID!): PersonNode
  allTeams(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
  ): TeamNodeNodeConnection
  teamById(id: ID!): TeamNode
  allInstitutions(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
    id_In: [ID]
    name: String
    name_Icontains: String
    city: String
    city_Icontains: String
    country: String
    country_Icontains: String
    mail: String
    mail_Icontains: String
    website: String
    website_Icontains: String
  ): InstitutionNodeNodeConnection
  institutionById(id: ID!): InstitutionNode
  _debug: DjangoDebug
  allWebsiteProjects(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    id: ID
  ): WebsiteProjectNodeNodeConnection
  websiteProjetById(id: ID!): WebsiteProjectNode
  currentUser: UserNode
  allUserGroups(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
  ): UserGroupNodeNodeConnection
  allUsers(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
  ): UserNodeNodeConnection
  allAnalysisForImport(datasetId: ID!): [ImportAnalysisNode]
  allAnnotationSpectrograms(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    start_Lte: DateTime
    end_Gte: DateTime
    filename_Icontains: String
    phase: AnnotationPhaseType
    annotationCampaign: ID
    annotator: ID
    annotationTasks_Status: AnnotationTaskStatus
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationSpectrogramNodeNodeConnection
  allDatasetsForImport: [ImportDatasetNode]
  annotationLabelsForDeploymentId(
    deploymentId: ID!

    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotation_AnnotationPhase_AnnotationCampaignId: ID
    annotation_AnnotationPhase_Phase: AnnotationPhaseType
    annotation_AnnotatorId: ID
  ): AnnotationLabelNodeNodeConnection
  annotationPhaseByCampaignPhase(campaignId: ID!, phaseType: AnnotationPhaseType!): AnnotationPhaseNode
  allDatasets(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int

    """Ordering"""
    orderBy: String
  ): DatasetNodeNodeConnection
  datasetById(id: ID!): DatasetNode
  allSpectrogramAnalysis(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeNodeConnection
  allLabelSets(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    name: String
    description: String
    labels: ID
  ): LabelSetNodeNodeConnection
  allConfidenceSets(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    name: String
    desc: String
    confidenceIndicators: ID
  ): ConfidenceSetNodeNodeConnection
  allDetectors(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
  ): DetectorNodeNodeConnection
  allAnnotationCampaigns(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeNodeConnection
  annotationCampaignById(id: ID!): AnnotationCampaignNode
  allAnnotationPhases(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotationCampaignId: ID
    annotationCampaign_OwnerId: ID
    annotationFileRanges_AnnotatorId: ID
    isCampaignArchived: Boolean
    phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationPhaseNodeNodeConnection
  allAnnotationFileRanges(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    annotationPhase_AnnotationCampaign: ID
    annotationPhase_Phase: AnnotationPhaseType
  ): AnnotationFileRangeNodeNodeConnection
  annotationSpectrogramById(id: ID!): AnnotationSpectrogramNode
}

type LabelNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [LabelNode]!
  totalCount: Int
}

type PageInfoExtra {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
}

type LabelNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  source: SourceNode!
  sound: SoundNode
  nickname: String

  """Other name found in the bibliography for this label"""
  associatedNames: [String]
  parent: LabelNode
  shape: SignalShapeEnum
  plurality: SignalPluralityEnum
  minFrequency: Int
  maxFrequency: Int
  meanDuration: Float
  description: String
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
  acousticDetectors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, algorithmName: String, algorithmName_Icontains: String): AcousticDetectorSpecificationNodeConnection!
  channelConfigurationDetectorSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, filter: String, filter_Icontains: String, configuration: String, configuration_Icontains: String): ChannelConfigurationDetectorSpecificationNodeConnection!
  labelSet(offset: Int, before: String, after: String, first: Int, last: Int, annotation_AnnotationPhase_AnnotationCampaignId: ID, annotation_AnnotationPhase_Phase: AnnotationPhaseType, annotation_AnnotatorId: ID): AnnotationLabelNodeConnection!
}

"""For fetching object id instead of Node id"""
interface ExtendedInterface {
  """The ID of the object"""
  id: ID!
}

type SourceNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  englishName: String!
  latinName: String
  frenchName: String
  codeName: String
  taxon: String
  parent: SourceNode
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, latinName: String, latinName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SourceNodeConnection!
  labels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
}

type SourceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SourceNodeEdge]!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `SourceNode` and its cursor."""
type SourceNodeEdge {
  """The item at the end of the edge"""
  node: SourceNode

  """A cursor for use in pagination"""
  cursor: String!
}

type LabelNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LabelNodeEdge]!
}

"""A Relay edge containing a `LabelNode` and its cursor."""
type LabelNodeEdge {
  """The item at the end of the edge"""
  node: LabelNode

  """A cursor for use in pagination"""
  cursor: String!
}

enum SignalShapeEnum {
  Stationary
  Pulse
  FrequencyModulation
}

enum SignalPluralityEnum {
  One
  Set
  RepetitiveSet
}

type SoundNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  englishName: String!
  frenchName: String
  codeName: String
  taxon: String
  parent: SoundNode
  children(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SoundNodeConnection!
  labels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
}

type SoundNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SoundNodeEdge]!
}

"""A Relay edge containing a `SoundNode` and its cursor."""
type SoundNodeEdge {
  """The item at the end of the edge"""
  node: SoundNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AcousticDetectorSpecificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AcousticDetectorSpecificationNodeEdge]!
}

"""
A Relay edge containing a `AcousticDetectorSpecificationNode` and its cursor.
"""
type AcousticDetectorSpecificationNodeEdge {
  """The item at the end of the edge"""
  node: AcousticDetectorSpecificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AcousticDetectorSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  detectedLabels: [LabelNode]
  minFrequency: Int
  maxFrequency: Int
  algorithmName: String
  detectorSet(offset: Int, before: String, after: String, first: Int, last: Int): DetectorNodeConnection!
}

type DetectorNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DetectorNodeEdge]!
}

"""A Relay edge containing a `DetectorNode` and its cursor."""
type DetectorNodeEdge {
  """The item at the end of the edge"""
  node: DetectorNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Detector schema"""
type DetectorNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  specification: AcousticDetectorSpecificationNode
  configurations: [DetectorConfigurationNode]
}

"""DetectorConfiguration schema"""
type DetectorConfigurationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  configuration: String!
  detector: DetectorNode!
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
}

type AnnotationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationNodeEdge]!
}

"""A Relay edge containing a `AnnotationNode` and its cursor."""
type AnnotationNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Annotation schema"""
type AnnotationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  type: AnnotationType!
  startTime: Float
  endTime: Float
  startFrequency: Float
  endFrequency: Float
  label: AnnotationLabelNode!
  confidence: ConfidenceNode
  annotationPhase: AnnotationPhaseNode!
  annotator: UserNode

  """Expertise level of the annotator."""
  annotatorExpertiseLevel: ApiAnnotationAnnotatorExpertiseLevelChoices
  spectrogram: AnnotationSpectrogramNode!
  analysis: SpectrogramAnalysisNode!
  detectorConfiguration: DetectorConfigurationNode

  """Acoustic features add a better description to the signal"""
  acousticFeatures: AcousticFeaturesNode
  isUpdateOf: AnnotationNode
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  updatedTo(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationComments(offset: Int, before: String, after: String, first: Int, last: Int, annotation_Isnull: Boolean, author: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationCommentNodeConnection!
  validations(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
  ): AnnotationValidationNodeNodeConnection
  comments(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotation_Isnull: Boolean
    author: ID
    annotationPhase_Phase: AnnotationPhaseType
  ): AnnotationCommentNodeNodeConnection
}

"""From Annotation.Type"""
enum AnnotationType {
  Weak
  Point
  Box
}

"""Label schema"""
type AnnotationLabelNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  metadataxLabel: LabelNode
  annotationSet(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  labelsetSet(offset: Int, before: String, after: String, first: Int, last: Int, name: String, description: String, labels: ID): LabelSetNodeConnection!
  annotationcampaignSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
  uses(deploymentId: ID): Int!
}

type LabelSetNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LabelSetNodeEdge]!
}

"""A Relay edge containing a `LabelSetNode` and its cursor."""
type LabelSetNodeEdge {
  """The item at the end of the edge"""
  node: LabelSetNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""LabelSet schema"""
type LabelSetNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  labels: [AnnotationLabelNode]!
  annotationcampaignSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
}

type AnnotationCampaignNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationCampaignNodeEdge]!
}

"""A Relay edge containing a `AnnotationCampaignNode` and its cursor."""
type AnnotationCampaignNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationCampaignNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""AnnotationCampaign schema"""
type AnnotationCampaignNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  name: String!
  description: String
  instructionsUrl: String
  deadline: Date
  labelSet: LabelSetNode
  labelsWithAcousticFeatures: [AnnotationLabelNode]
  allowPointAnnotation: Boolean!
  dataset: DatasetNode!
  analysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
  allowImageTuning: Boolean!
  allowColormapTuning: Boolean!
  colormapDefault: String
  colormapInvertedDefault: Boolean
  owner: UserNode!
  confidenceSet: ConfidenceSetNode
  archive: ArchiveNode
  phases(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotationCampaignId: ID
    annotationCampaign_OwnerId: ID
    annotationFileRanges_AnnotatorId: ID
    isCampaignArchived: Boolean
    phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationPhaseNodeNodeConnection
  isArchived: Boolean!
  canManage: Boolean!
  datasetName: String!
  tasksCount: Int!
  userTasksCount: Int!
  completedTasksCount: Int!
  userCompletedTasksCount: Int!
  detectors: [DetectorNode]
  annotators: [UserNode]
  spectrogramsCount: Int!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""Dataset schema"""
type DatasetNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  name: String!
  description: String
  path: String!
  owner: UserNode!
  legacy: Boolean!
  relatedChannelConfigurations(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], recorderSpecification_Isnull: Boolean, detectorSpecification_Isnull: Boolean, continuous: Boolean, dutyCycleOn: Int, dutyCycleOn_Lt: Int, dutyCycleOn_Lte: Int, dutyCycleOn_Gt: Int, dutyCycleOn_Gte: Int, dutyCycleOff: Int, dutyCycleOff_Lt: Int, dutyCycleOff_Lte: Int, dutyCycleOff_Gt: Int, dutyCycleOff_Gte: Int, instrumentDepth: Int, instrumentDepth_Lt: Int, instrumentDepth_Lte: Int, instrumentDepth_Gt: Int, instrumentDepth_Gte: Int, timezone: String, harvestStartingDate: DateTime, harvestStartingDate_Lt: DateTime, harvestStartingDate_Lte: DateTime, harvestStartingDate_Gt: DateTime, harvestStartingDate_Gte: DateTime, harvestEndingDate: DateTime, harvestEndingDate_Lt: DateTime, harvestEndingDate_Lte: DateTime, harvestEndingDate_Gt: DateTime, harvestEndingDate_Gte: DateTime, datasetId: ID): ChannelConfigurationNodeConnection!
  spectrogramAnalysis(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeNodeConnection
  annotationCampaigns(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
  analysisCount: Int!
  spectrogramCount: Int!
  start: DateTime
  end: DateTime
}

"""User node"""
type UserNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  lastLogin: DateTime

  """
  Designates that this user has all permissions without explicitly assigning them.
  """
  isSuperuser: Boolean!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  firstName: String!
  lastName: String!
  email: String!

  """Designates whether the user can log into this admin site."""
  isStaff: Boolean!

  """
  Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
  """
  isActive: Boolean!
  dateJoined: DateTime!
  annotatorGroups(offset: Int, before: String, after: String, first: Int, last: Int): UserGroupNodeConnection!
  archives(offset: Int, before: String, after: String, first: Int, last: Int, date: DateTime, byUser: ID): ArchiveNodeConnection!
  datasetSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Ordering"""
    orderBy: String
  ): DatasetNodeConnection!
  spectrogramAnalysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
  annotationTasks(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    status: AnnotationTaskStatus
    spectrogram_Filename_Icontains: String
    spectrogram_Start_Lte: DateTime
    spectrogram_End_Gte: DateTime
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationTaskNodeConnection!
  annotationFileRanges(offset: Int, before: String, after: String, first: Int, last: Int, annotator: ID, annotationPhase_AnnotationCampaign: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationFileRangeNodeConnection!
  createdPhases(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotationCampaignId: ID
    annotationCampaign_OwnerId: ID
    annotationFileRanges_AnnotatorId: ID
    isCampaignArchived: Boolean
    phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationPhaseNodeConnection!
  endedPhases(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotationCampaignId: ID
    annotationCampaign_OwnerId: ID
    annotationFileRanges_AnnotatorId: ID
    isCampaignArchived: Boolean
    phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationPhaseNodeConnection!
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationcampaignSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
  annotationComments(offset: Int, before: String, after: String, first: Int, last: Int, annotation_Isnull: Boolean, author: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationCommentNodeConnection!
  annotationResultsValidation(offset: Int, before: String, after: String, first: Int, last: Int, annotator: ID): AnnotationValidationNodeConnection!
  expertise: ExpertiseLevelType
  displayName: String!
  isAdmin: Boolean!
}

type UserGroupNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserGroupNodeEdge]!
}

"""A Relay edge containing a `UserGroupNode` and its cursor."""
type UserGroupNodeEdge {
  """The item at the end of the edge"""
  node: UserGroupNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""User group node"""
type UserGroupNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  users: [UserNode]
}

type ArchiveNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ArchiveNodeEdge]!
}

"""A Relay edge containing a `ArchiveNode` and its cursor."""
type ArchiveNodeEdge {
  """The item at the end of the edge"""
  node: ArchiveNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""Archive schema"""
type ArchiveNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  date: DateTime!
  byUser: UserNode
  annotationCampaign: AnnotationCampaignNode
}

type DatasetNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DatasetNodeEdge]!
}

"""A Relay edge containing a `DatasetNode` and its cursor."""
type DatasetNodeEdge {
  """The item at the end of the edge"""
  node: DatasetNode

  """A cursor for use in pagination"""
  cursor: String!
}

type SpectrogramAnalysisNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SpectrogramAnalysisNodeEdge]!
}

"""A Relay edge containing a `SpectrogramAnalysisNode` and its cursor."""
type SpectrogramAnalysisNodeEdge {
  """The item at the end of the edge"""
  node: SpectrogramAnalysisNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""SpectrogramAnalysis schema"""
type SpectrogramAnalysisNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  name: String!
  description: String
  path: String!
  legacy: Boolean!
  start: DateTime
  end: DateTime
  owner: UserNode!
  dataset: DatasetNode!

  """Duration of the segmented data (in s)"""
  dataDuration: Float
  fft: FFTNode!
  colormap: ColormapNode!
  dynamicMin: Float!
  dynamicMax: Float!
  legacyConfiguration: LegacySpectrogramConfigurationNode
  spectrograms(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    start: DateTime
    start_Lt: DateTime
    start_Lte: DateTime
    start_Gt: DateTime
    start_Gte: DateTime
    end: DateTime
    end_Lt: DateTime
    end_Lte: DateTime
    end_Gt: DateTime
    end_Gte: DateTime
    campaignId: ID
    phaseType: AnnotationPhaseType
    annotatorId: ID
    isTaskCompleted: Boolean
    hasAnnotations: Boolean
    annotatedByAnnotator: ID
    annotatedByDetector: ID
    annotatedWithLabel: String
    annotatedWithConfidence: String
    annotatedWithFeatures: Boolean

    """Ordering"""
    orderBy: String
  ): SpectrogramNodeNodeConnection
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationCampaigns(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
}

"""FFT schema"""
type FFTNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  nfft: Int!
  windowSize: Int!
  overlap: Decimal!
  samplingFrequency: Int!
  scaling: String
  legacy: Boolean!
  spectrogramAnalysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
}

"""The `Decimal` scalar type represents a python Decimal."""
scalar Decimal

"""Colormap schema"""
type ColormapNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  spectrogramAnalysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
}

"""LegacySpectrogramConfiguration schema"""
type LegacySpectrogramConfigurationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  spectrogramAnalysis: SpectrogramAnalysisNode!
  folder: String!
  audioFilesSubtypes: [String!]
  channelCount: Int
  fileOverlap: Int
  zoomLevel: Int!
  hpFilterMinFrequency: Int!
  dataNormalization: String!
  frequencyResolution: Float!
  spectrogramNormalization: String!
  zscoreDuration: String
  windowType: String
  peakVoltage: Float
  sensitivityDb: Float
  temporalResolution: Float
  gainDb: Float
  linearFrequencyScale: LinearScaleNode
  multiLinearFrequencyScale: MultiLinearScaleNode
  scaleName: String
}

"""LinearScale schema"""
type LinearScaleNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String
  ratio: Float!
  minValue: Float!
  maxValue: Float!
  outerScales(offset: Int, before: String, after: String, first: Int, last: Int): MultiLinearScaleNodeConnection!
  legacyspectrogramconfigurationSet(offset: Int, before: String, after: String, first: Int, last: Int): LegacySpectrogramConfigurationNodeConnection!
}

type MultiLinearScaleNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MultiLinearScaleNodeEdge]!
}

"""A Relay edge containing a `MultiLinearScaleNode` and its cursor."""
type MultiLinearScaleNodeEdge {
  """The item at the end of the edge"""
  node: MultiLinearScaleNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""MultiLinearScale schema"""
type MultiLinearScaleNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String
  innerScales: [LinearScaleNode]
  legacyspectrogramconfigurationSet(offset: Int, before: String, after: String, first: Int, last: Int): LegacySpectrogramConfigurationNodeConnection!
}

type LegacySpectrogramConfigurationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LegacySpectrogramConfigurationNodeEdge]!
}

"""
A Relay edge containing a `LegacySpectrogramConfigurationNode` and its cursor.
"""
type LegacySpectrogramConfigurationNodeEdge {
  """The item at the end of the edge"""
  node: LegacySpectrogramConfigurationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type SpectrogramNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SpectrogramNode]!
  totalCount: Int!
  start: DateTime
  end: DateTime
}

"""Spectrogram schema"""
type SpectrogramNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  format: FileFormatNode!
  filename: String!
  start: DateTime!
  end: DateTime!
  analysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
  annotationTasks(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    status: AnnotationTaskStatus
    spectrogram_Filename_Icontains: String
    spectrogram_Start_Lte: DateTime
    spectrogram_End_Gte: DateTime
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationTaskNodeConnection!
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationComments(offset: Int, before: String, after: String, first: Int, last: Int, annotation_Isnull: Boolean, author: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationCommentNodeConnection!
  duration: Int!
}

type FileFormatNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Format of the file"""
  name: String!
  channelConfigurationRecorderSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], samplingFrequency: Int, samplingFrequency_Lt: Int, samplingFrequency_Lte: Int, samplingFrequency_Gt: Int, samplingFrequency_Gte: Int, sampleDepth: Int, sampleDepth_Lt: Int, sampleDepth_Lte: Int, sampleDepth_Gt: Int, sampleDepth_Gte: Int, gain: Float, gain_Lt: Float, gain_Lte: Float, gain_Gt: Float, gain_Gte: Float, channelName: String, channelName_Icontains: String): ChannelConfigurationRecorderSpecificationNodeConnection!
  channelConfigurationDetectorSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, filter: String, filter_Icontains: String, configuration: String, configuration_Icontains: String): ChannelConfigurationDetectorSpecificationNodeConnection!
  spectrogramSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    start_Lte: DateTime
    end_Gte: DateTime
    filename_Icontains: String
    phase: AnnotationPhaseType
    annotationCampaign: ID
    annotator: ID
    annotationTasks_Status: AnnotationTaskStatus
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationSpectrogramNodeConnection!
}

type ChannelConfigurationRecorderSpecificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ChannelConfigurationRecorderSpecificationNodeEdge]!
}

"""
A Relay edge containing a `ChannelConfigurationRecorderSpecificationNode` and its cursor.
"""
type ChannelConfigurationRecorderSpecificationNodeEdge {
  """The item at the end of the edge"""
  node: ChannelConfigurationRecorderSpecificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ChannelConfigurationRecorderSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  recorder: EquipmentNode!
  hydrophone: EquipmentNode!
  recordingFormats: [FileFormatNode]

  """Sampling frequency of the recording channel (in Hertz)."""
  samplingFrequency: Int!

  """
  Number of quantization bits used to represent each sample by the recorder channel (in bits).
  """
  sampleDepth: Int!

  """
  Gain of the channel (recorder), with correction factors if applicable, without hydrophone sensibility (in dB). If end-to-end calibration with hydrophone sensibility, set it in Sensitivity and set Gain to 0 dB.<br>Gain G of the channel such that : data(uPa) = data(volt)*10^((-Sh-G)/20). See Sensitivity for Sh definition.
  """
  gain: Float!

  """Name of the channel used for recording."""
  channelName: String
  channelConfiguration: ChannelConfigurationNode
}

type EquipmentNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  model: EquipmentModelNode!
  serialNumber: String!

  """"""
  ownerId: BigInt!
  purchaseDate: Date
  name: String

  """Required only for hydrophones"""
  sensitivity: Float
  maintenances(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], typeId: ID, typeId_In: [ID], maintainerId: ID, maintainerId_In: [ID], maintainerInstitutionId: ID, maintainerInstitutionId_In: [ID], platformId: ID, platformId_In: [ID], equipmentId: ID, equipmentId_In: [ID], date: Date, date_Lt: Date, date_Lte: Date, date_Gt: Date, date_Gte: Date): MaintenanceNodeConnection!
  channelConfigurationRecorderSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], samplingFrequency: Int, samplingFrequency_Lt: Int, samplingFrequency_Lte: Int, samplingFrequency_Gt: Int, samplingFrequency_Gte: Int, sampleDepth: Int, sampleDepth_Lt: Int, sampleDepth_Lte: Int, sampleDepth_Gt: Int, sampleDepth_Gte: Int, gain: Float, gain_Lt: Float, gain_Lte: Float, gain_Gt: Float, gain_Gte: Float, channelName: String, channelName_Icontains: String): ChannelConfigurationRecorderSpecificationNodeConnection!
  channelConfigurationHydrophoneSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], samplingFrequency: Int, samplingFrequency_Lt: Int, samplingFrequency_Lte: Int, samplingFrequency_Gt: Int, samplingFrequency_Gte: Int, sampleDepth: Int, sampleDepth_Lt: Int, sampleDepth_Lte: Int, sampleDepth_Gt: Int, sampleDepth_Gte: Int, gain: Float, gain_Lt: Float, gain_Lte: Float, gain_Gt: Float, gain_Gte: Float, channelName: String, channelName_Icontains: String): ChannelConfigurationRecorderSpecificationNodeConnection!
  channelConfigurationDetectorSpecifications(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, filter: String, filter_Icontains: String, configuration: String, configuration_Icontains: String): ChannelConfigurationDetectorSpecificationNodeConnection!
  channelConfigurations(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], recorderSpecification_Isnull: Boolean, detectorSpecification_Isnull: Boolean, continuous: Boolean, dutyCycleOn: Int, dutyCycleOn_Lt: Int, dutyCycleOn_Lte: Int, dutyCycleOn_Gt: Int, dutyCycleOn_Gte: Int, dutyCycleOff: Int, dutyCycleOff_Lt: Int, dutyCycleOff_Lte: Int, dutyCycleOff_Gt: Int, dutyCycleOff_Gte: Int, instrumentDepth: Int, instrumentDepth_Lt: Int, instrumentDepth_Lte: Int, instrumentDepth_Gt: Int, instrumentDepth_Gte: Int, timezone: String, harvestStartingDate: DateTime, harvestStartingDate_Lt: DateTime, harvestStartingDate_Lte: DateTime, harvestStartingDate_Gt: DateTime, harvestStartingDate_Gte: DateTime, harvestEndingDate: DateTime, harvestEndingDate_Lt: DateTime, harvestEndingDate_Lte: DateTime, harvestEndingDate_Gt: DateTime, harvestEndingDate_Gte: DateTime, datasetId: ID): ChannelConfigurationNodeConnection!
  owner: ContactUnion
}

type EquipmentModelNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  provider: InstitutionNode!
  batterySlotsCount: Int
  batteryType: String
  cables: String
  equipments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], serialNumber: String, serialNumber_Icontains: String, purchaseDate: Date, purchaseDate_Lt: Date, purchaseDate_Lte: Date, purchaseDate_Gt: Date, purchaseDate_Gte: Date, name: String, name_Icontains: String, sensitivity: Float, sensitivity_Lt: Float, sensitivity_Lte: Float, sensitivity_Gt: Float, sensitivity_Gte: Float, sensitivity_Isnull: Boolean): EquipmentNodeConnection!
  specifications: [EquipmentSpecificationUnion]
}

type InstitutionNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  city: String
  country: String
  mail: String
  website: String
  contactRelations(offset: Int, before: String, after: String, first: Int, last: Int): PersonInstitutionRelationNodeConnection!
  teamSet(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String): TeamNodeConnection!
  persons(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], firstName: String, firstName_Icontains: String, lastName: String, lastName_Icontains: String, mail: String, mail_Icontains: String, website: String, website_Icontains: String): PersonNodeConnection!
  bibliographyAuthors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  providedEquipments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_In: [String], batterySlotsCount: Int, batterySlotsCount_Lt: Int, batterySlotsCount_Lte: Int, batterySlotsCount_Gt: Int, batterySlotsCount_Gte: Int, batterySlotsCount_Isnull: Boolean, batteryType: String, batteryType_In: [String], cables: String, cables_In: [String]): EquipmentModelNodeConnection!
  providedPlatforms(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], ownerId: BigInt, ownerId_In: [BigInt], providerId: ID, providerId_In: [ID], name: String, name_Icontains: String): PlatformNodeConnection!
  performedMaintenances(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], typeId: ID, typeId_In: [ID], maintainerId: ID, maintainerId_In: [ID], maintainerInstitutionId: ID, maintainerInstitutionId_In: [ID], platformId: ID, platformId_In: [ID], equipmentId: ID, equipmentId_In: [ID], date: Date, date_Lt: Date, date_Lte: Date, date_Gt: Date, date_Gte: Date): MaintenanceNodeConnection!
}

type PersonInstitutionRelationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PersonInstitutionRelationNodeEdge]!
}

"""
A Relay edge containing a `PersonInstitutionRelationNode` and its cursor.
"""
type PersonInstitutionRelationNodeEdge {
  """The item at the end of the edge"""
  node: PersonInstitutionRelationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type PersonInstitutionRelationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  person: PersonNode!
  institution: InstitutionNode!
  team: TeamNode
  fromDate: Date
  toDate: Date
}

type PersonNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  firstName: String!
  lastName: String!
  mail: String
  website: String
  institutions(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, city: String, city_Icontains: String, country: String, country_Icontains: String, mail: String, mail_Icontains: String, website: String, website_Icontains: String): InstitutionNodeConnection!
  teams(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String): TeamNodeConnection!
  institutionRelations: [PersonInstitutionRelationNode]
  authors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  performedMaintenances(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], typeId: ID, typeId_In: [ID], maintainerId: ID, maintainerId_In: [ID], maintainerInstitutionId: ID, maintainerInstitutionId_In: [ID], platformId: ID, platformId_In: [ID], equipmentId: ID, equipmentId_In: [ID], date: Date, date_Lt: Date, date_Lte: Date, date_Gt: Date, date_Gte: Date): MaintenanceNodeConnection!
  initialNames: String
  currentInstitutions: [InstitutionNode]
}

type InstitutionNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InstitutionNodeEdge]!
}

"""A Relay edge containing a `InstitutionNode` and its cursor."""
type InstitutionNodeEdge {
  """The item at the end of the edge"""
  node: InstitutionNode

  """A cursor for use in pagination"""
  cursor: String!
}

type TeamNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TeamNodeEdge]!
}

"""A Relay edge containing a `TeamNode` and its cursor."""
type TeamNodeEdge {
  """The item at the end of the edge"""
  node: TeamNode

  """A cursor for use in pagination"""
  cursor: String!
}

type TeamNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  institution: InstitutionNode!
  mail: String
  website: String
  contactRelations(offset: Int, before: String, after: String, first: Int, last: Int): PersonInstitutionRelationNodeConnection!
  persons(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], firstName: String, firstName_Icontains: String, lastName: String, lastName_Icontains: String, mail: String, mail_Icontains: String, website: String, website_Icontains: String): PersonNodeConnection!
}

type PersonNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PersonNodeEdge]!
}

"""A Relay edge containing a `PersonNode` and its cursor."""
type PersonNodeEdge {
  """The item at the end of the edge"""
  node: PersonNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AuthorNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AuthorNodeEdge]!
}

"""A Relay edge containing a `AuthorNode` and its cursor."""
type AuthorNodeEdge {
  """The item at the end of the edge"""
  node: AuthorNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AuthorNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  order: Int
  person: PersonNode!
  institutions(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, city: String, city_Icontains: String, country: String, country_Icontains: String, mail: String, mail_Icontains: String, website: String, website_Icontains: String): InstitutionNodeConnection!
}

type MaintenanceNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [MaintenanceNodeEdge]!
}

"""A Relay edge containing a `MaintenanceNode` and its cursor."""
type MaintenanceNodeEdge {
  """The item at the end of the edge"""
  node: MaintenanceNode

  """A cursor for use in pagination"""
  cursor: String!
}

type MaintenanceNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  type: MaintenanceTypeNode!
  date: Date!
  description: String
  maintainer: PersonNode!
  maintainerInstitution: InstitutionNode!
  platform: PlatformNode
  equipment: EquipmentNode
}

type MaintenanceTypeNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  description: String
  interval: Float
  maintenances(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], typeId: ID, typeId_In: [ID], maintainerId: ID, maintainerId_In: [ID], maintainerInstitutionId: ID, maintainerInstitutionId_In: [ID], platformId: ID, platformId_In: [ID], equipmentId: ID, equipmentId_In: [ID], date: Date, date_Lt: Date, date_Lte: Date, date_Gt: Date, date_Gte: Date): MaintenanceNodeConnection!
}

type PlatformNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """"""
  ownerId: BigInt
  provider: InstitutionNode!
  type: PlatformTypeNode!
  name: String
  description: String
  maintenances(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], typeId: ID, typeId_In: [ID], maintainerId: ID, maintainerId_In: [ID], maintainerInstitutionId: ID, maintainerInstitutionId_In: [ID], platformId: ID, platformId_In: [ID], equipmentId: ID, equipmentId_In: [ID], date: Date, date_Lt: Date, date_Lte: Date, date_Gt: Date, date_Gte: Date): MaintenanceNodeConnection!

  """Support of the deployed instruments"""
  deployments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], projectId: ID, projectId_In: [ID], siteId: ID, siteId_In: [ID], campaignId: ID, campaignId_In: [ID], platformId: ID, platformId_In: [ID], longitude: Float, longitude_Lt: Float, longitude_Lte: Float, longitude_Gt: Float, longitude_Gte: Float, latitude: Float, latitude_Lt: Float, latitude_Lte: Float, latitude_Gt: Float, latitude_Gte: Float, name: String, name_Icontains: String, bathymetricDepth: Int, bathymetricDepth_Lt: Int, bathymetricDepth_Lte: Int, bathymetricDepth_Gt: Int, bathymetricDepth_Gte: Int, deploymentDate: DateTime, deploymentDate_Lt: DateTime, deploymentDate_Lte: DateTime, deploymentDate_Gt: DateTime, deploymentDate_Gte: DateTime, deploymentVessel: String, deploymentVessel_Icontains: String, recoveryDate: DateTime, recoveryDate_Lt: DateTime, recoveryDate_Lte: DateTime, recoveryDate_Gt: DateTime, recoveryDate_Gte: DateTime, recoveryVessel: String, recoveryVessel_Icontains: String, description_Icontains: String, project_WebsiteProject_Id: Decimal): DeploymentNodeConnection!
  owner: ContactUnion
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

type PlatformTypeNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  isMobile: Boolean!
  platforms(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], ownerId: BigInt, ownerId_In: [BigInt], providerId: ID, providerId_In: [ID], name: String, name_Icontains: String): PlatformNodeConnection!
}

type PlatformNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PlatformNodeEdge]!
}

"""A Relay edge containing a `PlatformNode` and its cursor."""
type PlatformNodeEdge {
  """The item at the end of the edge"""
  node: PlatformNode

  """A cursor for use in pagination"""
  cursor: String!
}

type DeploymentNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeploymentNodeEdge]!
}

"""A Relay edge containing a `DeploymentNode` and its cursor."""
type DeploymentNodeEdge {
  """The item at the end of the edge"""
  node: DeploymentNode

  """A cursor for use in pagination"""
  cursor: String!
}

type DeploymentNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Project associated to this deployment"""
  project: ProjectNodeOverride!

  """Longitude of the platform position (WGS84 decimal degree)."""
  longitude: Float!

  """Latitude of the platform position (WGS84 decimal degrees)."""
  latitude: Float!

  """Name of the deployment."""
  name: String

  """
  Conceptual location. A site may group together several platforms in relatively close proximity, or describes a location where regular deployments are carried out.
  """
  site: SiteNode

  """Campaign during which the instrument was deployed."""
  campaign: CampaignNode

  """Support of the deployed instruments"""
  platform: PlatformNode

  """
  Underwater depth of ocean floor at the platform position (in positive meters).
  """
  bathymetricDepth: Int

  """Date and time at which the measurement system was deployed in UTC."""
  deploymentDate: DateTime

  """Name of the vehicle associated with the deployment."""
  deploymentVessel: String

  """Date and time at which the measurement system was recovered in UTC."""
  recoveryDate: DateTime

  """Name of the vehicle associated with the recovery."""
  recoveryVessel: String
  contacts: [ContactRelationNode]

  """
  Optional description of deployment and recovery conditions (weather, technical issues,...).
  """
  description: String
  channelConfigurations(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], recorderSpecification_Isnull: Boolean, detectorSpecification_Isnull: Boolean, continuous: Boolean, dutyCycleOn: Int, dutyCycleOn_Lt: Int, dutyCycleOn_Lte: Int, dutyCycleOn_Gt: Int, dutyCycleOn_Gte: Int, dutyCycleOff: Int, dutyCycleOff_Lt: Int, dutyCycleOff_Lte: Int, dutyCycleOff_Gt: Int, dutyCycleOff_Gte: Int, instrumentDepth: Int, instrumentDepth_Lt: Int, instrumentDepth_Lte: Int, instrumentDepth_Gt: Int, instrumentDepth_Gte: Int, timezone: String, harvestStartingDate: DateTime, harvestStartingDate_Lt: DateTime, harvestStartingDate_Lte: DateTime, harvestStartingDate_Gt: DateTime, harvestStartingDate_Gte: DateTime, harvestEndingDate: DateTime, harvestEndingDate_Lt: DateTime, harvestEndingDate_Lte: DateTime, harvestEndingDate_Gt: DateTime, harvestEndingDate_Gte: DateTime, datasetId: ID): ChannelConfigurationNodeConnection!
  mobilePositions: [DeploymentMobilePositionNode]
}

type ProjectNodeOverride implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Name of the project"""
  name: String!
  contacts: [ContactRelationNode]
  accessibility: AccessibilityEnum

  """Digital Object Identifier of the data, if existing."""
  doi: String

  """
  Description of the type of the project (e.g., research, marine renewable energies, long monitoring,...).
  """
  projectType: ProjectTypeNode
  startDate: Date
  endDate: Date

  """Description of the goal of the project."""
  projectGoal: String
  financing: FinancingEnum

  """Project associated to this campaign"""
  campaigns(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, projectId: ID, projectId_In: [ID]): CampaignNodeConnection!

  """Project associated to this site"""
  sites(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, projectId: ID, projectId_In: [ID]): SiteNodeConnection!

  """Project associated to this deployment"""
  deployments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], projectId: ID, projectId_In: [ID], siteId: ID, siteId_In: [ID], campaignId: ID, campaignId_In: [ID], platformId: ID, platformId_In: [ID], longitude: Float, longitude_Lt: Float, longitude_Lte: Float, longitude_Gt: Float, longitude_Gte: Float, latitude: Float, latitude_Lt: Float, latitude_Lte: Float, latitude_Gt: Float, latitude_Gte: Float, name: String, name_Icontains: String, bathymetricDepth: Int, bathymetricDepth_Lt: Int, bathymetricDepth_Lte: Int, bathymetricDepth_Gt: Int, bathymetricDepth_Gte: Int, deploymentDate: DateTime, deploymentDate_Lt: DateTime, deploymentDate_Lte: DateTime, deploymentDate_Gt: DateTime, deploymentDate_Gte: DateTime, deploymentVessel: String, deploymentVessel_Icontains: String, recoveryDate: DateTime, recoveryDate_Lt: DateTime, recoveryDate_Lte: DateTime, recoveryDate_Gt: DateTime, recoveryDate_Gte: DateTime, recoveryVessel: String, recoveryVessel_Icontains: String, description_Icontains: String, project_WebsiteProject_Id: Decimal): DeploymentNodeConnection!
  websiteProject: WebsiteProjectNode
}

type ContactRelationNode implements ExtendedInterface {
  role: RoleEnum
  contactType: String!

  """The ID of the object"""
  id: ID!
  contact: ContactUnion
}

enum RoleEnum {
  MainContact
  Funder
  ProjectOwner
  ProjectManager
  DatasetSupplier
  DatasetProducer
  ProductionDatabase
  ContactPoint
}

union ContactUnion = PersonNode | TeamNode | InstitutionNode

enum AccessibilityEnum {
  Confidential
  UponRequest
  OpenAccess
}

type ProjectTypeNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Description of the type of the project"""
  name: String!

  """
  Description of the type of the project (e.g., research, marine renewable energies, long monitoring,...).
  """
  projects(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, accessibility: AccessibilityEnum, doi: String, startDate: Date, startDate_Lte: Date, startDate_Lt: Date, startDate_Gte: Date, startDate_Gt: Date, endDate: Date, endDate_Lte: Date, endDate_Lt: Date, endDate_Gte: Date, endDate_Gt: Date, projectGoal: String, projectGoal_Icontains: String, financing: FinancingEnum): ProjectNodeOverrideConnection!
}

type ProjectNodeOverrideConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ProjectNodeOverrideEdge]!
}

"""A Relay edge containing a `ProjectNodeOverride` and its cursor."""
type ProjectNodeOverrideEdge {
  """The item at the end of the edge"""
  node: ProjectNodeOverride

  """A cursor for use in pagination"""
  cursor: String!
}

enum FinancingEnum {
  Public
  Private
  Mixte
  NotFinanced
}

type CampaignNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CampaignNodeEdge]!
}

"""A Relay edge containing a `CampaignNode` and its cursor."""
type CampaignNodeEdge {
  """The item at the end of the edge"""
  node: CampaignNode

  """A cursor for use in pagination"""
  cursor: String!
}

type CampaignNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Name of the campaign during which the instrument was deployed."""
  name: String!

  """Project associated to this campaign"""
  project: ProjectNodeOverride!

  """Campaign during which the instrument was deployed."""
  deployments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], projectId: ID, projectId_In: [ID], siteId: ID, siteId_In: [ID], campaignId: ID, campaignId_In: [ID], platformId: ID, platformId_In: [ID], longitude: Float, longitude_Lt: Float, longitude_Lte: Float, longitude_Gt: Float, longitude_Gte: Float, latitude: Float, latitude_Lt: Float, latitude_Lte: Float, latitude_Gt: Float, latitude_Gte: Float, name: String, name_Icontains: String, bathymetricDepth: Int, bathymetricDepth_Lt: Int, bathymetricDepth_Lte: Int, bathymetricDepth_Gt: Int, bathymetricDepth_Gte: Int, deploymentDate: DateTime, deploymentDate_Lt: DateTime, deploymentDate_Lte: DateTime, deploymentDate_Gt: DateTime, deploymentDate_Gte: DateTime, deploymentVessel: String, deploymentVessel_Icontains: String, recoveryDate: DateTime, recoveryDate_Lt: DateTime, recoveryDate_Lte: DateTime, recoveryDate_Gt: DateTime, recoveryDate_Gte: DateTime, recoveryVessel: String, recoveryVessel_Icontains: String, description_Icontains: String, project_WebsiteProject_Id: Decimal): DeploymentNodeConnection!
}

type SiteNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SiteNodeEdge]!
}

"""A Relay edge containing a `SiteNode` and its cursor."""
type SiteNodeEdge {
  """The item at the end of the edge"""
  node: SiteNode

  """A cursor for use in pagination"""
  cursor: String!
}

type SiteNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """
  Name of the platform conceptual location. A site may group together several platforms in relatively close proximity, or describes a location where regular deployments are carried out.
  """
  name: String!

  """Project associated to this site"""
  project: ProjectNodeOverride!

  """
  Conceptual location. A site may group together several platforms in relatively close proximity, or describes a location where regular deployments are carried out.
  """
  deployments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], projectId: ID, projectId_In: [ID], siteId: ID, siteId_In: [ID], campaignId: ID, campaignId_In: [ID], platformId: ID, platformId_In: [ID], longitude: Float, longitude_Lt: Float, longitude_Lte: Float, longitude_Gt: Float, longitude_Gte: Float, latitude: Float, latitude_Lt: Float, latitude_Lte: Float, latitude_Gt: Float, latitude_Gte: Float, name: String, name_Icontains: String, bathymetricDepth: Int, bathymetricDepth_Lt: Int, bathymetricDepth_Lte: Int, bathymetricDepth_Gt: Int, bathymetricDepth_Gte: Int, deploymentDate: DateTime, deploymentDate_Lt: DateTime, deploymentDate_Lte: DateTime, deploymentDate_Gt: DateTime, deploymentDate_Gte: DateTime, deploymentVessel: String, deploymentVessel_Icontains: String, recoveryDate: DateTime, recoveryDate_Lt: DateTime, recoveryDate_Lte: DateTime, recoveryDate_Gt: DateTime, recoveryDate_Gte: DateTime, recoveryVessel: String, recoveryVessel_Icontains: String, description_Icontains: String, project_WebsiteProject_Id: Decimal): DeploymentNodeConnection!
}

"""Project node"""
type WebsiteProjectNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  title: String!
  intro: String!
  start: Date
  end: Date
  body: String!
  thumbnail: String!
  otherContacts: [String!]
  metadataxProject: ProjectNodeOverride
}

type ChannelConfigurationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ChannelConfigurationNodeEdge]!
}

"""A Relay edge containing a `ChannelConfigurationNode` and its cursor."""
type ChannelConfigurationNodeEdge {
  """The item at the end of the edge"""
  node: ChannelConfigurationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type ChannelConfigurationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  deployment: DeploymentNode!
  status: ChannelConfigurationStatusEnum

  """Each specification is dedicated to one file."""
  recorderSpecification: ChannelConfigurationRecorderSpecificationNode

  """Each specification is dedicated to one file."""
  detectorSpecification: ChannelConfigurationDetectorSpecificationNode
  storages: [EquipmentNode]

  """
  Boolean indicating if the record is continuous (1) or has a duty cycle (0).
  """
  continuous: Boolean

  """
  If it's not Continuous, time length (in second) during which the recorder is on.
  """
  dutyCycleOn: Int

  """
  If it's not Continuous, time length (in second) during which the recorder is off.
  """
  dutyCycleOff: Int

  """Immersion depth of instrument (in positive meters)."""
  instrumentDepth: Int
  timezone: String
  extraInformation: String

  """
  Harvest start date at which the channel configuration was idle to record (in UTC).
  """
  harvestStartingDate: DateTime

  """
  Harvest stop date at which the channel configuration was stopped (in UTC).
  """
  harvestEndingDate: DateTime

  """Date at which the channel configuration started to record (in UTC)."""
  recordStartDate: DateTime

  """
  Date at which the channel configuration finished to record in (in UTC).
  """
  recordEndDate: DateTime
  datasets(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int

    """Ordering"""
    orderBy: String
  ): DatasetNodeConnection!
}

enum ChannelConfigurationStatusEnum {
  Active
  Failed
  Lost
}

type ChannelConfigurationDetectorSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  detector: EquipmentNode!
  outputFormats: [FileFormatNode]
  labels: [LabelNode]

  """Minimum frequency (in Hertz)."""
  minFrequency: Int

  """Maximum frequency (in Hertz)."""
  maxFrequency: Int
  filter: String
  configuration: String
  channelConfiguration: ChannelConfigurationNode
}

type DeploymentMobilePositionNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Related deployment"""
  deployment: DeploymentNode!

  """Datetime for the mobile platform position"""
  datetime: DateTime!

  """Longitude of the mobile platform"""
  longitude: Float!

  """Latitude of the mobile platform"""
  latitude: Float!

  """Hydrophone depth of the mobile platform (In positive meters)"""
  depth: Float!

  """Heading of the mobile platform"""
  heading: Float

  """Pitch of the mobile platform"""
  pitch: Float

  """Roll of the mobile platform"""
  roll: Float
}

type EquipmentModelNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentModelNodeEdge]!
}

"""A Relay edge containing a `EquipmentModelNode` and its cursor."""
type EquipmentModelNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentModelNode

  """A cursor for use in pagination"""
  cursor: String!
}

type EquipmentNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [EquipmentNodeEdge]!
}

"""A Relay edge containing a `EquipmentNode` and its cursor."""
type EquipmentNodeEdge {
  """The item at the end of the edge"""
  node: EquipmentNode

  """A cursor for use in pagination"""
  cursor: String!
}

union EquipmentSpecificationUnion = AcousticDetectorSpecificationNode | HydrophoneSpecificationNode | StorageSpecificationNode | RecorderSpecificationNode

type HydrophoneSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  directivity: HydrophoneDirectivityEnum

  """Minimal temperature where the hydrophone operates (in degree Celsius)"""
  operatingMinTemperature: Float

  """Maximal temperature where the hydrophone operates (in degree Celsius)"""
  operatingMaxTemperature: Float

  """
  Lower limiting frequency (in Hz) for a more or less flat response of the hydrophone, pre-amplification included if applicable.
  """
  minBandwidth: Float

  """
  Upper limiting frequency (in Hz) within a more or less flat response of the hydrophone, pre-amplification included if applicable.
  """
  maxBandwidth: Float

  """
  Lowest level which the hydrophone can handle (dB SPL RMS or peak), pre-amplification included if applicable.
  """
  minDynamicRange: Float

  """
  Highest level which the hydrophone can handle (dB SPL RMS or peak), pre-amplification included if applicable.
  """
  maxDynamicRange: Float

  """Minimum depth at which hydrophone operates (in positive meters)."""
  minOperatingDepth: Float

  """Maximum depth at which hydrophone operates (in positive meters)."""
  maxOperatingDepth: Float

  """
  Self noise of the hydrophone (dB re 1Pa^2/Hz), pre-amplification included if applicable.<br>Average on bandwidth or a fix frequency (generally @5kHz for example). Possibility to 'below sea-state zero' (equivalent to around 30dB @5kHz) could be nice because it is often described like that.
  """
  noiseFloor: Float
}

enum HydrophoneDirectivityEnum {
  OmniDirectional
  BiDirectional
  UniDirectional
  Cardioid
  Supercardioid
}

type StorageSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  capacity: [String!]!
  type: String
}

type RecorderSpecificationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Number of all the channels on the recorder, even if unused."""
  channelsCount: Int
  storageSlotsCount: Int
  storageMaximumCapacity: [String!]
  storageType: String
}

type ChannelConfigurationDetectorSpecificationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ChannelConfigurationDetectorSpecificationNodeEdge]!
}

"""
A Relay edge containing a `ChannelConfigurationDetectorSpecificationNode` and its cursor.
"""
type ChannelConfigurationDetectorSpecificationNodeEdge {
  """The item at the end of the edge"""
  node: ChannelConfigurationDetectorSpecificationNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AnnotationSpectrogramNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationSpectrogramNodeEdge]!
}

"""A Relay edge containing a `AnnotationSpectrogramNode` and its cursor."""
type AnnotationSpectrogramNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationSpectrogramNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AnnotationSpectrogramNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  format: FileFormatNode!
  filename: String!
  start: DateTime!
  end: DateTime!
  analysis(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    dataset: ID
    annotationCampaigns_Id: ID

    """Ordering"""
    orderBy: String
  ): SpectrogramAnalysisNodeConnection!
  annotationTasks(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    status: AnnotationTaskStatus
    spectrogram_Filename_Icontains: String
    spectrogram_Start_Lte: DateTime
    spectrogram_End_Gte: DateTime
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationTaskNodeConnection!
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationComments(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotation_Isnull: Boolean
    author: ID
    annotationPhase_Phase: AnnotationPhaseType
  ): AnnotationCommentNodeNodeConnection
  duration: Int!
  isAssigned(campaignId: ID!, phase: AnnotationPhaseType!): Boolean!
  audioPath(analysisId: ID!): String
  path(analysisId: ID!): String!
  task(campaignId: ID!, phase: AnnotationPhaseType!): AnnotationTaskNode
}

type AnnotationTaskNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationTaskNodeEdge]!
}

"""A Relay edge containing a `AnnotationTaskNode` and its cursor."""
type AnnotationTaskNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationTaskNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""AnnotationTask schema"""
type AnnotationTaskNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  status: AnnotationTaskStatus!
  annotationPhase: AnnotationPhaseNode!
  annotator: UserNode!
  spectrogram: AnnotationSpectrogramNode!
  userAnnotations(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    confidence_Label: String
    label_Name: String
    detectorConfiguration_Detector: ID
    acousticFeatures_Exists: Boolean
    isValidatedBy: ID
    isUpdated: Boolean
    annotator: ID
  ): AnnotationNodeNodeConnection
  userComments(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotation_Isnull: Boolean
    author: ID
    annotationPhase_Phase: AnnotationPhaseType
  ): AnnotationCommentNodeNodeConnection
  annotationsToCheck(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    confidence_Label: String
    label_Name: String
    detectorConfiguration_Detector: ID
    acousticFeatures_Exists: Boolean
    isValidatedBy: ID
    isUpdated: Boolean
    annotator: ID
  ): AnnotationNodeNodeConnection
}

"""From AnnotationTask.Status"""
enum AnnotationTaskStatus {
  Created
  Finished
}

"""AnnotationPhase schema"""
type AnnotationPhaseNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  phase: AnnotationPhaseType!
  annotationCampaign: AnnotationCampaignNode!
  createdAt: DateTime!
  createdBy: UserNode!
  endedAt: DateTime
  endedBy: UserNode
  annotationTasks(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    status: AnnotationTaskStatus
    spectrogram_Filename_Icontains: String
    spectrogram_Start_Lte: DateTime
    spectrogram_End_Gte: DateTime
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationTaskNodeConnection!
  annotationFileRanges(offset: Int, before: String, after: String, first: Int, last: Int, annotator: ID, annotationPhase_AnnotationCampaign: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationFileRangeNodeConnection!
  annotations(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  annotationComments(offset: Int, before: String, after: String, first: Int, last: Int, annotation_Isnull: Boolean, author: ID, annotationPhase_Phase: AnnotationPhaseType): AnnotationCommentNodeConnection!
  annotationCampaignId: ID!
  isCompleted: Boolean!
  isOpen: Boolean!
  hasAnnotations: Boolean!
  canManage: Boolean!
  tasksCount: Int!
  userTasksCount: Int!
  completedTasksCount: Int!
  userCompletedTasksCount: Int!
}

"""From AnnotationPhase.Type"""
enum AnnotationPhaseType {
  Annotation
  Verification
}

type AnnotationFileRangeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationFileRangeNodeEdge]!
}

"""A Relay edge containing a `AnnotationFileRangeNode` and its cursor."""
type AnnotationFileRangeNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationFileRangeNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""AnnotationFileRange schema"""
type AnnotationFileRangeNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  firstFileIndex: Int!
  lastFileIndex: Int!
  fromDatetime: DateTime!
  toDatetime: DateTime!
  filesCount: Int!
  annotator: UserNode!
  annotationPhase: AnnotationPhaseNode!
  annotationTasks(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    annotator: ID
    status: AnnotationTaskStatus
    spectrogram_Filename_Icontains: String
    spectrogram_Start_Lte: DateTime
    spectrogram_End_Gte: DateTime
    annotations_Exists: Boolean
    annotations_Confidence_Label: String
    annotations_LabelName: String
    annotations_AcousticFeatures_Exists: Boolean
    annotations_Detector: ID
    annotations_Annotator: ID

    """Ordering"""
    orderBy: String
  ): AnnotationTaskNodeNodeConnection
  spectrograms(
    """Query limit"""
    limit: Int

    """Query offset"""
    offset: Int

    """Query order"""
    ordering: String
    before: String
    after: String
    first: Int
    last: Int
    start: DateTime
    start_Lt: DateTime
    start_Lte: DateTime
    start_Gt: DateTime
    start_Gte: DateTime
    end: DateTime
    end_Lt: DateTime
    end_Lte: DateTime
    end_Gt: DateTime
    end_Gte: DateTime
    campaignId: ID
    phaseType: AnnotationPhaseType
    annotatorId: ID
    isTaskCompleted: Boolean
    hasAnnotations: Boolean
    annotatedByAnnotator: ID
    annotatedByDetector: ID
    annotatedWithLabel: String
    annotatedWithConfidence: String
    annotatedWithFeatures: Boolean

    """Ordering"""
    orderBy: String
  ): SpectrogramNodeNodeConnection
}

type AnnotationTaskNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationTaskNode]!
  totalCount: Int
}

type AnnotationCommentNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationCommentNodeEdge]!
}

"""A Relay edge containing a `AnnotationCommentNode` and its cursor."""
type AnnotationCommentNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationCommentNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""AnnotationComment schema"""
type AnnotationCommentNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  comment: String!
  annotation: AnnotationNode
  annotationPhase: AnnotationPhaseNode!
  author: UserNode!
  spectrogram: AnnotationSpectrogramNode!
  createdAt: DateTime!
}

type AnnotationNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationNode]!
  totalCount: Int
}

type AnnotationCommentNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationCommentNode]!
  totalCount: Int
}

type AnnotationPhaseNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationPhaseNodeEdge]!
}

"""A Relay edge containing a `AnnotationPhaseNode` and its cursor."""
type AnnotationPhaseNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationPhaseNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AnnotationValidationNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationValidationNodeEdge]!
}

"""A Relay edge containing a `AnnotationValidationNode` and its cursor."""
type AnnotationValidationNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationValidationNode

  """A cursor for use in pagination"""
  cursor: String!
}

"""AnnotationValidation schema"""
type AnnotationValidationNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  annotation: AnnotationNode!
  annotator: UserNode!
  isValid: Boolean!
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
}

"""From ExpertiseLevel"""
enum ExpertiseLevelType {
  Expert
  Average
  Novice
}

type SpectrogramAnalysisNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SpectrogramAnalysisNode]!
  totalCount: Int
}

"""ConfidenceSet schema"""
type ConfidenceSetNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
  desc: String
  confidenceIndicators: [ConfidenceNode]
  annotationcampaignSet(
    offset: Int
    before: String
    after: String
    first: Int
    last: Int
    phases_AnnotationFileRanges_AnnotatorId: ID
    ownerId: ID
    isArchived: Boolean
    phases_Phase: AnnotationPhaseType

    """search"""
    search: String

    """Ordering"""
    orderBy: String
  ): AnnotationCampaignNodeConnection!
}

"""Confidence schema"""
type ConfidenceNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  label: String!
  level: Int!
  annotationSet(offset: Int, before: String, after: String, first: Int, last: Int, confidence_Label: String, label_Name: String, detectorConfiguration_Detector: ID, acousticFeatures_Exists: Boolean, isValidatedBy: ID, isUpdated: Boolean, annotator: ID): AnnotationNodeConnection!
  confidenceIndicatorSets(offset: Int, before: String, after: String, first: Int, last: Int, name: String, desc: String, confidenceIndicators: ID): ConfidenceSetNodeConnection!
  isDefault: Boolean
}

type ConfidenceSetNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ConfidenceSetNodeEdge]!
}

"""A Relay edge containing a `ConfidenceSetNode` and its cursor."""
type ConfidenceSetNodeEdge {
  """The item at the end of the edge"""
  node: ConfidenceSetNode

  """A cursor for use in pagination"""
  cursor: String!
}

type AnnotationPhaseNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationPhaseNode]!
  totalCount: Int
}

"""An enumeration."""
enum ApiAnnotationAnnotatorExpertiseLevelChoices {
  """Expert"""
  E

  """Average"""
  A

  """Novice"""
  N
}

"""Annotation schema"""
type AcousticFeaturesNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """[Hz] Frequency at the beginning of the signal"""
  startFrequency: Float

  """[Hz] Frequency at the end of the signal"""
  endFrequency: Float

  """Number of relative maximum frequency in the signal"""
  relativeMaxFrequencyCount: Int

  """Number of relative minimum frequency in the signal"""
  relativeMinFrequencyCount: Int

  """If the signal has harmonics"""
  hasHarmonics: Boolean
  trend: SignalTrendType

  """Number of steps (flat segment) in the signal"""
  stepsCount: Int
  annotation: AnnotationNode
}

"""From SignalTrend"""
enum SignalTrendType {
  Flat
  Ascending
  Descending
  Modulated
}

type AnnotationValidationNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationValidationNode]!
  totalCount: Int
}

type AnnotationLabelNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AnnotationLabelNodeEdge]!
}

"""A Relay edge containing a `AnnotationLabelNode` and its cursor."""
type AnnotationLabelNodeEdge {
  """The item at the end of the edge"""
  node: AnnotationLabelNode

  """A cursor for use in pagination"""
  cursor: String!
}

type SoundNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SoundNode]!
  totalCount: Int
}

type SourceNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SourceNode]!
  totalCount: Int
}

type AuthorNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AuthorNode]!
  totalCount: Int
}

type ArticleNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ArticleNode]!
  totalCount: Int
}

type ArticleNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  title: String!
  doi: String
  status: BibliographyStatusEnum!

  """Required for any published bibliography"""
  publicationDate: Date
  type: BibliographyTypeEnum!
  journal: String!
  volumes: String
  pagesFrom: Int
  pagesTo: Int
  issueNb: Int
  articleNb: Int
  authors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  relatedProjects(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, accessibility: AccessibilityEnum, doi: String, startDate: Date, startDate_Lte: Date, startDate_Lt: Date, startDate_Gte: Date, startDate_Gt: Date, endDate: Date, endDate_Lte: Date, endDate_Lt: Date, endDate_Gte: Date, endDate_Gt: Date, projectGoal: String, projectGoal_Icontains: String, financing: FinancingEnum): ProjectNodeOverrideConnection!
  relatedSounds(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SoundNodeConnection!
  relatedSources(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, latinName: String, latinName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SourceNodeConnection!
  relatedLabels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
  tags: [TagNode]
}

enum BibliographyStatusEnum {
  Upcoming
  Published
}

enum BibliographyTypeEnum {
  Software
  Article
  Conference
  Poster
}

type TagNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  name: String!
}

type SoftwareNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SoftwareNode]!
  totalCount: Int
}

type SoftwareNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  title: String!
  doi: String
  status: BibliographyStatusEnum!

  """Required for any published bibliography"""
  publicationDate: Date
  type: BibliographyTypeEnum!
  authors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  relatedProjects(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, accessibility: AccessibilityEnum, doi: String, startDate: Date, startDate_Lte: Date, startDate_Lt: Date, startDate_Gte: Date, startDate_Gt: Date, endDate: Date, endDate_Lte: Date, endDate_Lt: Date, endDate_Gte: Date, endDate_Gt: Date, projectGoal: String, projectGoal_Icontains: String, financing: FinancingEnum): ProjectNodeOverrideConnection!
  relatedSounds(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SoundNodeConnection!
  relatedSources(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, latinName: String, latinName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SourceNodeConnection!
  relatedLabels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
  publicationPlace: String!
  repositoryUrl: String
  tags: [TagNode]
}

type ConferenceNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ConferenceNode]!
  totalCount: Int
}

type ConferenceNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  title: String!
  doi: String
  status: BibliographyStatusEnum!

  """Required for any published bibliography"""
  publicationDate: Date
  type: BibliographyTypeEnum!
  authors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  relatedProjects(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, accessibility: AccessibilityEnum, doi: String, startDate: Date, startDate_Lte: Date, startDate_Lt: Date, startDate_Gte: Date, startDate_Gt: Date, endDate: Date, endDate_Lte: Date, endDate_Lt: Date, endDate_Gte: Date, endDate_Gt: Date, projectGoal: String, projectGoal_Icontains: String, financing: FinancingEnum): ProjectNodeOverrideConnection!
  relatedSounds(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SoundNodeConnection!
  relatedSources(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, latinName: String, latinName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SourceNodeConnection!
  relatedLabels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
  conferenceName: String!
  conferenceLocation: String!
  conferenceAbstractBookUrl: String
  tags: [TagNode]
}

type PosterNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [PosterNode]!
  totalCount: Int
}

type PosterNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!
  title: String!
  doi: String
  status: BibliographyStatusEnum!

  """Required for any published bibliography"""
  publicationDate: Date
  type: BibliographyTypeEnum!
  authors(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], order: Int, order_Lt: Int, order_Lte: Int, order_Gt: Int, order_Gte: Int, bibliographyId: ID, bibliographyId_In: [ID], personId: ID, personId_In: [ID]): AuthorNodeConnection!
  relatedProjects(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, accessibility: AccessibilityEnum, doi: String, startDate: Date, startDate_Lte: Date, startDate_Lt: Date, startDate_Gte: Date, startDate_Gt: Date, endDate: Date, endDate_Lte: Date, endDate_Lt: Date, endDate_Gte: Date, endDate_Gt: Date, projectGoal: String, projectGoal_Icontains: String, financing: FinancingEnum): ProjectNodeOverrideConnection!
  relatedSounds(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SoundNodeConnection!
  relatedSources(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], parentId: ID, parentId_In: [ID], englishName: String, englishName_Icontains: String, latinName: String, latinName_Icontains: String, frenchName: String, frenchName_Icontains: String, codeName: String, codeName_Icontains: String, taxon: String, taxon_Icontains: String): SourceNodeConnection!
  relatedLabels(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], sourceId: ID, sourceId_In: [ID], soundId: ID, soundId_In: [ID], parentId: ID, parentId_In: [ID], nickname: String, nickname_Icontains: String, shape: SignalShapeEnum, plurality: SignalPluralityEnum, minFrequency: Int, minFrequency_Lt: Int, minFrequency_Lte: Int, minFrequency_Gt: Int, minFrequency_Gte: Int, maxFrequency: Int, maxFrequency_Lt: Int, maxFrequency_Lte: Int, maxFrequency_Gt: Int, maxFrequency_Gte: Int, meanDuration: Float, meanDuration_Lt: Float, meanDuration_Lte: Float, meanDuration_Gt: Float, meanDuration_Gte: Float): LabelNodeConnection!
  conferenceName: String!
  conferenceLocation: String!
  conferenceAbstractBookUrl: String
  posterUrl: String
  tags: [TagNode]
}

type BibliographyUnionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BibliographyUnionEdge]!
}

"""A Relay edge containing a `BibliographyUnion` and its cursor."""
type BibliographyUnionEdge {
  """The item at the end of the edge"""
  node: BibliographyUnion

  """A cursor for use in pagination"""
  cursor: String!
}

union BibliographyUnion = ArticleNode | SoftwareNode | ConferenceNode | PosterNode

type MaintenanceNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [MaintenanceNode]!
  totalCount: Int
}

type MaintenanceTypeNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [MaintenanceTypeNode]!
  totalCount: Int
}

type PlatformNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [PlatformNode]!
  totalCount: Int
}

type PlatformTypeNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [PlatformTypeNode]!
  totalCount: Int
}

type EquipmentNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [EquipmentNode]!
  totalCount: Int
}

type EquipmentModelNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [EquipmentModelNode]!
  totalCount: Int
}

type FileFormatNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [FileFormatNode]!
  totalCount: Int
}

type AudioFileNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AudioFileNode]!
  totalCount: Int
}

type AudioFileNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Name of the file, with extension."""
  filename: String!

  """Format of the audio file."""
  format: FileFormatNode!

  """Description of the path to access the data."""
  storageLocation: String

  """Total number of bytes of the audio file (in bytes)."""
  fileSize: BigInt
  accessibility: AccessibilityEnum

  """"""
  propertyId: BigInt!
  channelConfigurations(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], recorderSpecification_Isnull: Boolean, detectorSpecification_Isnull: Boolean, continuous: Boolean, dutyCycleOn: Int, dutyCycleOn_Lt: Int, dutyCycleOn_Lte: Int, dutyCycleOn_Gt: Int, dutyCycleOn_Gte: Int, dutyCycleOff: Int, dutyCycleOff_Lt: Int, dutyCycleOff_Lte: Int, dutyCycleOff_Gt: Int, dutyCycleOff_Gte: Int, instrumentDepth: Int, instrumentDepth_Lt: Int, instrumentDepth_Lte: Int, instrumentDepth_Gt: Int, instrumentDepth_Gte: Int, timezone: String, harvestStartingDate: DateTime, harvestStartingDate_Lt: DateTime, harvestStartingDate_Lte: DateTime, harvestStartingDate_Gt: DateTime, harvestStartingDate_Gte: DateTime, harvestEndingDate: DateTime, harvestEndingDate_Lt: DateTime, harvestEndingDate_Lte: DateTime, harvestEndingDate_Gt: DateTime, harvestEndingDate_Gte: DateTime, datasetId: ID): ChannelConfigurationNodeConnection!
  samplingFrequency: Int!
  initialTimestamp: Int!
  duration: Int!
  sampleDepth: Int
}

type DetectionFileNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [DetectionFileNode]!
  totalCount: Int
}

type DetectionFileNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Name of the file, with extension."""
  filename: String!

  """Format of the audio file."""
  format: FileFormatNode!

  """Description of the path to access the data."""
  storageLocation: String

  """Total number of bytes of the audio file (in bytes)."""
  fileSize: BigInt
  accessibility: AccessibilityEnum

  """"""
  propertyId: BigInt!
  channelConfigurations(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], recorderSpecification_Isnull: Boolean, detectorSpecification_Isnull: Boolean, continuous: Boolean, dutyCycleOn: Int, dutyCycleOn_Lt: Int, dutyCycleOn_Lte: Int, dutyCycleOn_Gt: Int, dutyCycleOn_Gte: Int, dutyCycleOff: Int, dutyCycleOff_Lt: Int, dutyCycleOff_Lte: Int, dutyCycleOff_Gt: Int, dutyCycleOff_Gte: Int, instrumentDepth: Int, instrumentDepth_Lt: Int, instrumentDepth_Lte: Int, instrumentDepth_Gt: Int, instrumentDepth_Gte: Int, timezone: String, harvestStartingDate: DateTime, harvestStartingDate_Lt: DateTime, harvestStartingDate_Lte: DateTime, harvestStartingDate_Gt: DateTime, harvestStartingDate_Gte: DateTime, harvestEndingDate: DateTime, harvestEndingDate_Lt: DateTime, harvestEndingDate_Lte: DateTime, harvestEndingDate_Gt: DateTime, harvestEndingDate_Gte: DateTime, datasetId: ID): ChannelConfigurationNodeConnection!
  start: Int!
  end: Int!
}

type FileUnionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [FileUnionEdge]!
}

"""A Relay edge containing a `FileUnion` and its cursor."""
type FileUnionEdge {
  """The item at the end of the edge"""
  node: FileUnion

  """A cursor for use in pagination"""
  cursor: String!
}

union FileUnion = AudioFileNode | DetectionFileNode

type ProjectNodeOverrideNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ProjectNodeOverride]!
  totalCount: Int
}

type ProjectNode implements ExtendedInterface {
  """The ID of the object"""
  id: ID!

  """Name of the project"""
  name: String!
  contacts: [ContactRelationNode]
  accessibility: AccessibilityEnum

  """Digital Object Identifier of the data, if existing."""
  doi: String

  """
  Description of the type of the project (e.g., research, marine renewable energies, long monitoring,...).
  """
  projectType: ProjectTypeNode
  startDate: Date
  endDate: Date

  """Description of the goal of the project."""
  projectGoal: String
  financing: FinancingEnum

  """Project associated to this campaign"""
  campaigns(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, projectId: ID, projectId_In: [ID]): CampaignNodeConnection!

  """Project associated to this site"""
  sites(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], name: String, name_Icontains: String, projectId: ID, projectId_In: [ID]): SiteNodeConnection!

  """Project associated to this deployment"""
  deployments(offset: Int, before: String, after: String, first: Int, last: Int, id: ID, id_In: [ID], projectId: ID, projectId_In: [ID], siteId: ID, siteId_In: [ID], campaignId: ID, campaignId_In: [ID], platformId: ID, platformId_In: [ID], longitude: Float, longitude_Lt: Float, longitude_Lte: Float, longitude_Gt: Float, longitude_Gte: Float, latitude: Float, latitude_Lt: Float, latitude_Lte: Float, latitude_Gt: Float, latitude_Gte: Float, name: String, name_Icontains: String, bathymetricDepth: Int, bathymetricDepth_Lt: Int, bathymetricDepth_Lte: Int, bathymetricDepth_Gt: Int, bathymetricDepth_Gte: Int, deploymentDate: DateTime, deploymentDate_Lt: DateTime, deploymentDate_Lte: DateTime, deploymentDate_Gt: DateTime, deploymentDate_Gte: DateTime, deploymentVessel: String, deploymentVessel_Icontains: String, recoveryDate: DateTime, recoveryDate_Lt: DateTime, recoveryDate_Lte: DateTime, recoveryDate_Gt: DateTime, recoveryDate_Gte: DateTime, recoveryVessel: String, recoveryVessel_Icontains: String, description_Icontains: String, project_WebsiteProject_Id: Decimal): DeploymentNodeConnection!
  websiteProject: WebsiteProjectNode
}

type ProjectTypeNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ProjectTypeNode]!
  totalCount: Int
}

type SiteNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [SiteNode]!
  totalCount: Int
}

type CampaignNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [CampaignNode]!
  totalCount: Int
}

type DeploymentNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [DeploymentNode]!
  totalCount: Int
}

type ChannelConfigurationNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ChannelConfigurationNode]!
  totalCount: Int
}

type PersonNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [PersonNode]!
  totalCount: Int
}

type TeamNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [TeamNode]!
  totalCount: Int
}

type InstitutionNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [InstitutionNode]!
  totalCount: Int
}

"""Debugging information for the current query."""
type DjangoDebug {
  """Executed SQL queries for this API query."""
  sql: [DjangoDebugSQL]

  """Raise exceptions for this API query."""
  exceptions: [DjangoDebugException]
}

"""Represents a single database query made to a Django managed DB."""
type DjangoDebugSQL {
  """The type of database being used (e.g. postrgesql, mysql, sqlite)."""
  vendor: String!

  """The Django database alias (e.g. 'default')."""
  alias: String!

  """The actual SQL sent to this database."""
  sql: String

  """Duration of this database query in seconds."""
  duration: Float!

  """The raw SQL of this query, without params."""
  rawSql: String!

  """JSON encoded database query parameters."""
  params: String!

  """Start time of this database query."""
  startTime: Float!

  """Stop time of this database query."""
  stopTime: Float!

  """Whether this database query took more than 10 seconds."""
  isSlow: Boolean!

  """Whether this database query was a SELECT."""
  isSelect: Boolean!

  """Postgres transaction ID if available."""
  transId: String

  """Postgres transaction status if available."""
  transStatus: String

  """Postgres isolation level if available."""
  isoLevel: String

  """Postgres connection encoding if available."""
  encoding: String
}

"""Represents a single exception raised."""
type DjangoDebugException {
  """The class of the exception"""
  excType: String!

  """The message of the exception"""
  message: String!

  """The stack trace"""
  stack: String!
}

type WebsiteProjectNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [WebsiteProjectNode]!
  totalCount: Int
}

type UserGroupNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [UserGroupNode]!
  totalCount: Int
}

type UserNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [UserNode]!
  totalCount: Int
}

"""Type for import dataset"""
type ImportAnalysisNode {
  name: String!
  path: String!
}

"""Annotation spectrogram node connection"""
type AnnotationSpectrogramNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationSpectrogramNode]!
  totalCount: Int!
  resumeSpectrogramId(campaignId: ID!, phase: AnnotationPhaseType!): ID
  previousSpectrogramId(spectrogramId: ID): ID
  nextSpectrogramId(spectrogramId: ID): ID
  currentIndex(spectrogramId: ID): Int
}

"""Type for import dataset"""
type ImportDatasetNode {
  name: String!
  path: String!
  legacy: Boolean
  analysis: [ImportAnalysisNode]
}

type AnnotationLabelNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationLabelNode]!
  totalCount: Int
}

type DatasetNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [DatasetNode]!
  totalCount: Int
}

type LabelSetNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [LabelSetNode]!
  totalCount: Int
}

type ConfidenceSetNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [ConfidenceSetNode]!
  totalCount: Int
}

type DetectorNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [DetectorNode]!
  totalCount: Int
}

type AnnotationCampaignNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationCampaignNode]!
  totalCount: Int
}

type AnnotationFileRangeNodeNodeConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfoExtra!

  """Contains the nodes in this connection."""
  results: [AnnotationFileRangeNode]!
  totalCount: Int
}

"""Global mutation"""
type Mutation {
  postSource(input: PostSourceMutationInput!): PostSourceMutationPayload
  deleteSource(id: ID): DeleteSourceMutation
  postSound(input: PostSoundMutationInput!): PostSoundMutationPayload
  deleteSound(id: ID): DeleteSoundMutation
  _debug: DjangoDebug

  """Update password mutation"""
  userUpdatePassword(input: UpdateUserPasswordMutationInput!): UpdateUserPasswordMutationPayload

  """Update user mutation"""
  currentUserUpdate(input: UpdateUserMutationInput!): UpdateUserMutationPayload

  """Import dataset mutation"""
  importDataset(legacy: Boolean, name: String!, path: String!): ImportDatasetMutation

  """"Import spectrogram analysis mutation"""
  importSpectrogramAnalysis(datasetName: String!, datasetPath: String!, legacy: Boolean, name: String!, path: String!): ImportAnalysisMutation
  createAnnotationCampaign(input: CreateAnnotationCampaignMutationInput!): CreateAnnotationCampaignMutationPayload
  updateAnnotationCampaign(input: UpdateAnnotationCampaignMutationInput!): UpdateAnnotationCampaignMutationPayload

  """Archive annotation campaign mutation"""
  archiveAnnotationCampaign(id: ID!): ArchiveAnnotationCampaignMutation

  """Create annotation phase of type "Verification" mutation"""
  createAnnotationPhase(campaignId: ID!, type: AnnotationPhaseType!): CreateAnnotationPhase
  updateAnnotationPhaseFileRanges(campaignId: ID!, fileRanges: [AnnotationFileRangeInput]!, force: Boolean, phaseType: AnnotationPhaseType!): UpdateAnnotationPhaseFileRangesMutation

  """Archive annotation phase mutation"""
  endAnnotationPhase(id: ID!): EndAnnotationPhaseMutation
  updateAnnotations(input: UpdateAnnotationsMutationInput!): UpdateAnnotationsMutationPayload
  updateAnnotationComments(input: UpdateAnnotationCommentsMutationInput!): UpdateAnnotationCommentsMutationPayload
  submitAnnotationTask(annotations: [AnnotationInput]!, campaignId: ID!, endedAt: DateTime!, phaseType: AnnotationPhaseType!, spectrogramId: ID!, startedAt: DateTime!, taskComments: [AnnotationCommentInput]!): SubmitAnnotationTaskMutation
}

type PostSourceMutationPayload {
  source: SourceNode
  errors: [ErrorType!]!
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

input PostSourceMutationInput {
  englishName: String!
  latinName: String
  frenchName: String
  codeName: String
  taxon: String
  parent: ID
  id: ID
  clientMutationId: String
}

type DeleteSourceMutation {
  ok: Boolean
}

type PostSoundMutationPayload {
  sound: SoundNode
  errors: [ErrorType!]!
  clientMutationId: String
}

input PostSoundMutationInput {
  englishName: String!
  frenchName: String
  codeName: String
  taxon: String
  parent: ID
  id: ID
  clientMutationId: String
}

type DeleteSoundMutation {
  ok: Boolean
}

"""Update password mutation"""
type UpdateUserPasswordMutationPayload {
  oldPassword: String!
  newPassword: String!
  errors: [ErrorType]
  clientMutationId: String
}

input UpdateUserPasswordMutationInput {
  oldPassword: String!
  newPassword: String!
  clientMutationId: String
}

"""Update user mutation"""
type UpdateUserMutationPayload {
  user: UserNode
  errors: [ErrorType!]!
  clientMutationId: String
}

input UpdateUserMutationInput {
  email: String
  id: ID
  clientMutationId: String
}

"""Import dataset mutation"""
type ImportDatasetMutation {
  ok: Boolean!
}

""""Import spectrogram analysis mutation"""
type ImportAnalysisMutation {
  ok: Boolean
}

type CreateAnnotationCampaignMutationPayload {
  annotationCampaign: AnnotationCampaignNode
  errors: [ErrorType!]!
  clientMutationId: String
}

input CreateAnnotationCampaignMutationInput {
  name: String!
  description: String
  instructionsUrl: String
  deadline: Date
  allowImageTuning: Boolean
  allowColormapTuning: Boolean
  colormapDefault: String
  colormapInvertedDefault: Boolean
  dataset: ID!
  analysis: [ID]!
  id: ID
  clientMutationId: String
}

type UpdateAnnotationCampaignMutationPayload {
  annotationCampaign: AnnotationCampaignNode
  errors: [ErrorType!]!
  clientMutationId: String
}

input UpdateAnnotationCampaignMutationInput {
  labelSet: ID
  confidenceSet: ID
  labelsWithAcousticFeatures: [ID]
  allowPointAnnotation: Boolean
  id: ID
  clientMutationId: String
}

"""Archive annotation campaign mutation"""
type ArchiveAnnotationCampaignMutation {
  ok: Boolean!
}

"""Create annotation phase of type "Verification" mutation"""
type CreateAnnotationPhase {
  id: ID!
}

type UpdateAnnotationPhaseFileRangesMutation {
  errors: [[ErrorType!]]!
}

input AnnotationFileRangeInput {
  id: ID
  annotatorId: ID
  firstFileIndex: Int!
  lastFileIndex: Int!
}

"""Archive annotation phase mutation"""
type EndAnnotationPhaseMutation {
  ok: Boolean!
}

type UpdateAnnotationsMutationPayload {
  errors: [[ErrorType]]
  clientMutationId: String
}

input UpdateAnnotationsMutationInput {
  campaignId: ID!
  phaseType: AnnotationPhaseType!
  spectrogramId: ID!
  list: [AnnotationInput]!
  clientMutationId: String
}

input AnnotationInput {
  id: Int
  label: String!
  confidence: String
  comments: [AnnotationCommentSerializerInput]
  validations: [AnnotationValidationSerializerInput]
  acousticFeatures: AnnotationAcousticFeaturesSerializerInput
  startTime: Float
  endTime: Float
  startFrequency: Float
  endFrequency: Float
  annotationPhase: String!
  annotator: String
  analysis: String!
  detectorConfiguration: String
  isUpdateOf: String
}

input AnnotationCommentSerializerInput {
  id: Int
  comment: String!
  createdAt: DateTime
  annotation: String
  annotationPhase: String
  author: String
  spectrogram: String
}

input AnnotationValidationSerializerInput {
  id: Int
  isValid: Boolean!
  createdAt: DateTime
  lastUpdatedAt: DateTime
  annotation: String
  annotator: String
}

input AnnotationAcousticFeaturesSerializerInput {
  id: Int
  trend: SignalTrendType

  """[Hz] Frequency at the beginning of the signal"""
  startFrequency: Float

  """[Hz] Frequency at the end of the signal"""
  endFrequency: Float

  """Number of relative maximum frequency in the signal"""
  relativeMaxFrequencyCount: Int

  """Number of relative minimum frequency in the signal"""
  relativeMinFrequencyCount: Int

  """If the signal has harmonics"""
  hasHarmonics: Boolean

  """Number of steps (flat segment) in the signal"""
  stepsCount: Int
}

type UpdateAnnotationCommentsMutationPayload {
  errors: [[ErrorType]]
  clientMutationId: String
}

input UpdateAnnotationCommentsMutationInput {
  campaignId: ID!
  phaseType: AnnotationPhaseType!
  spectrogramId: ID!
  annotationId: ID
  list: [AnnotationCommentInput]!
  clientMutationId: String
}

input AnnotationCommentInput {
  id: Int
  comment: String!
}

type SubmitAnnotationTaskMutation {
  ok: Boolean!
  annotationErrors: [[ErrorType]]
  taskCommentsErrors: [[ErrorType]]
}